import streamlit as st
import pandas as pd
import plotly.express as px
import json
import re
from datetime import datetime, timedelta
import random

# Настройки страницы
st.set_page_config(layout="wide", page_title="Аналитика отзывов о Газпромбанке")

# Заголовок
st.title("Аналитика отзывов о Газпромбанке")

# Словарь продуктов и подкатегорий (ТОЧНО как в ТЗ, с корректировками для примера)
PRODUCT_CATEGORIES = {
    'Повседневные финансы и платежи': [
        'Ведение валютных счетов',
        'Дебетовые карты',
        'Мобильное приложение',
        'Переводы',
        'Зарплатные карты',
        'Обслуживание'
    ],
    'Сбережения и накопления': [
        'Срочные вклады',
        'Сберегательные счета',
        'Обезличенные металлические счета',
        'Накопительные счета'
    ],
    'Кредитование': [
        'Потребительские кредиты',
        'Кредитная карта',
        'Ипотечные кредиты',
        'Автокредиты',
        'Рефинансирование'
    ],
    'Инвестиции': [
        'Брокерский счет',
        'ИИС (Индивидуальный инвестиционный счет)',
        'ПИФы (Паевые инвестиционные фонды)',
        'Структурные продукты'
    ],
    'Страхование и защита': [
        'Страхование путешествий',
        'Страхование имущества',
        'Страхование от несчастных случаев и болезней',
        'Страхование при оформлении кредитов'
    ],
    'Премиальные услуги': [
        'Приват банкинг',
        'Депозитарные ячейки',
        'Услуги по консультированию и планированию'
    ]
}

# Обратное сопоставление подкатегорий к категориям
SUBCAT_TO_CAT = {sub: cat for cat, subs in PRODUCT_CATEGORIES.items() for sub in subs}

# Собираем все подкатегории и категории
ALL_CATEGORIES = list(PRODUCT_CATEGORIES.keys())
ALL_SUBCATEGORIES = [sub for subs in PRODUCT_CATEGORIES.values() for sub in subs]

# Словарь ключевых слов и фраз (расширенный предоставленными данными + дополнительные от меня)
KEYWORDS = {
    'Повседневные финансы и платежи': {
        'keywords': [
            'дебет', 'карт', 'счет', 'перевод', 'зарплат', 
            'мобиль', 'банк', 'платеж', 'валют', 'рубл', 'доллар', 
            'евро', 'снят', 'получен', 'банкомат', 'оплат', 'квитанц',
            'комисс', 'обслужван', 'отделени', 'клиент', 'очеред',
            'онлайн', 'приложен', 'интернет', 'смс', 'уведомлен',
            'средств', 'деньг', 'налич', 'безнал', 'сберкнижк',
            'выпис', 'баланс', 'остаток',
            # Дополнительные от меня
            'пополнен', 'терминал', 'касс', 'чек', 'реквизит', 
            'свифт', 'iban', 'bic', 'qr-код', 'nfc', 'контактлесс',
            'эплпэй', 'гуглпэй', 'самсунгпэй', 'мирпэй', 'транзакц'
        ],
        'phrases': [
            'дебетовая карта', 'зарплатная карта', 'мобильный банк', 
            'перевод денег', 'открыть счет', 'валютный счет',
            'банковский счет', 'расчетный счет', 'снять деньги',
            'получить деньги', 'оплатить услуги', 'комиссия за перевод',
            'обслуживание карты', 'отделение банка', 'очередь в банке',
            'интернет банк', 'мобильное приложение', 'смс информирование',
            'безналичный расчет', 'выписка по счету', 'остаток на счете',
            # Дополнительные от меня
            'пополнить карту', 'платежный терминал', 'чек об оплате',
            'банковские реквизиты', 'международный перевод', 'бесконтактная оплата',
            'apple pay', 'google pay', 'samsung pay', 'mir pay', 'qr-оплата'
        ]
    },
    'Сбережения и накопления': {
        'keywords': [
            'вклад', 'сберегательн', 'накопит', 'сбережен', 'металл', 
            'счет', 'срочн', 'процент', 'накоп', 'сберег', 'депозит',
            'ставк', 'доходност', 'капитализац', 'пополнен', 'снят',
            'пролонгац', 'проценты', 'начислен', 'забрат', 'получен',
            'золот', 'серебр', 'платин', 'паллад', 'слитк',
            'сберегательн', 'сертификат', 'накоплен', 'открыт', 'закрыт',
            # Дополнительные от меня
            'аккумуляц', 'резерв', 'копилк', 'пенсион', 'детск', 
            'наслед', 'целево', 'ежемесячн', 'квартальн', 'годов'
        ],
        'phrases': [
            'срочный вклад', 'сберегательный счет', 'металлический счет',
            'открыть вклад', 'накопительный счет', 'обезличенный металлический',
            'банковский вклад', 'депозитный счет', 'процентная ставка',
            'доход по вкладу', 'капитализация процентов', 'пополнить вклад',
            'снять со вклада', 'пролонгация вклада', 'начисление процентов',
            'забрать вклад', 'открыть депозит', 'золотой слиток',
            'сберегательный сертификат', 'накопить деньги',
            # Дополнительные от меня
            'финансовая подушка', 'пенсионные накопления', 'детский вклад',
            'целевой депозит', 'ежемесячные начисления', 'годовой процент'
        ]
    },
    'Кредитование': {
        'keywords': [
            'кредит', 'ипотек', 'автокредит', 'рефинансирован', 'заем', 
            'платеж', 'процент', 'ставк', 'одобрен', 'погашен', 'взят',
            'оформлен', 'долг', 'задолженност', 'просрочк', 'штраф',
            'пени', 'реструктуризац', 'решен', 'отказ', 'услов',
            'требован', 'справк', 'заявк', 'анкет', 'кредитн', 'истори',
            'скоринг', 'лимит', 'льготн', 'период', 'график', 'платеж',
            # Дополнительные от меня
            'овердрафт', 'лизинг', 'факторинг', 'гарант', 'поручител', 
            'залог', 'ипотечн', 'авто', 'потребител', 'микрозайм'
        ],
        'phrases': [
            'потребительский кредит', 'ипотечный кредит', 'взять кредит',
            'оформить кредит', 'кредитная карта', 'рефинансирование кредита',
            'автомобильный кредит', 'одобрение кредита', 'погашение кредита',
            'кредитная история', 'процентная ставка', 'ежемесячный платеж',
            'льготный период', 'график платежей', 'просрочка платежа',
            'штрафные санкции', 'реструктуризация долга', 'отказ в кредите',
            'кредитная заявка', 'справка о доходах', 'кредитный лимит',
            # Дополнительные от меня
            'овердрафт по карте', 'лизинг автомобиля', 'банковская гарантия',
            'залог имущества', 'микрозайм онлайн', 'кредит под залог'
        ]
    },
    'Инвестиции': {
        'keywords': [
            'инвест', 'брокер', 'иис', 'пиф', 'акци', 'облигац', 
            'бирж', 'портфель', 'доходност', 'структурн', 'пай',
            'фонд', 'ценн', 'бумаг', 'торгов', 'сделк', 'купля',
            'продаж', 'котировк', 'дивиденд', 'купон', 'выплат',
            'риск', 'прибыл', 'убыток', 'анализ', 'совет', 'управлен',
            'инвестор', 'трейдер', 'лиценз', 'комисс', 'тариф',
            # Дополнительные от меня
            'фьючерс', 'опцион', 'своп', 'хедж', 'диверсификац', 
            'волатильност', 'марж', 'леверидж', 'ipo', 'сплит'
        ],
        'phrases': [
            'брокерский счет', 'инвестиционный счет', 'паевой фонд',
            'структурный продукт', 'купить акции', 'инвестировать деньги',
            'индивидуальный инвестиционный счет', 'ценные бумаги',
            'торговля на бирже', 'инвестиционный портфель', 'доходность инвестиций',
            'покупка акций', 'продажа облигаций', 'дивидендные выплаты',
            'купонный доход', 'управление портфелем', 'инвестиционный риск',
            'биржевые торги', 'лицензия брокера', 'тарифы на обслуживание',
            'инвестиционная стратегия', 'финансовый советник',
            # Дополнительные от меня
            'торговля фьючерсами', 'опционные контракты', 'диверсификация портфеля',
            'маржинальная торговля', 'ipo компании', 'сплит акций'
        ]
    },
    'Страхование и защита': {
        'keywords': [
            'страхов', 'защит', 'путешеств', 'имуществ', 'несчастн', 
            'случа', 'болезн', 'риск', 'полис', 'страховк', 'выплат',
            'компенсац', 'дтп', 'авария', 'здоров', 'жизн', 'недвиж',
            'квартир', 'дом', 'машин', 'авто', 'лечен', 'больничн',
            'госпитализац', 'оплат', 'больниц', 'лекарств', 'ущерб', 'поврежден',
            'краж', 'пожар', 'затоплен', 'ответственност', 'гражданск',
            # Дополнительные от меня
            'каско', 'осаго', 'дмс', 'взр', 'турист', 'медстраховк', 
            'экстрен', 'эвакуац', 'репатриац', 'страховател', 'выгодоприобретател'
        ],
        'phrases': [
            'страхование путешественников', 'страхование имущества',
            'страховой полис', 'страхование от несчастных случаев',
            'страхование здоровья', 'страхование жизни', 'страхование квартиры',
            'страхование автомобиля', 'страховой случай', 'страховая выплата',
            'компенсация ущерба', 'добровольное страхование', 'обязательное страхование',
            'страхование ответственности', 'страхование ипотеки', 'медицинская страховка',
            'страхование выезжающих за рубеж', 'страховое возмещение',
            'оформить страховку', 'отказали в выплате', 'страховая компания',
            # Дополнительные от меня
            'каско на авто', 'осаго полис', 'дмс программа', 'страховка для туристов',
            'экстренная помощь', 'медицинская эвакуация', 'репатриация тела'
        ]
    },
    'Премиальные услуги': {
        'keywords': [
            'приват', 'премиум', 'депозитар', 'ячейк', 'консультирован', 
            'планирован', 'персонал', 'менеджер', 'эксклюзив', 'вип',
            'персональн', 'обслужван', 'услуг', 'богат', 'состоян',
            'капитал', 'наслед', 'сохран', 'приумножен', 'управлен',
            'актив', 'ценност', 'драгоценност', 'хранен', 'сейф',
            'конфиденциальн', 'индивидуальн', 'подход', 'решен',
            'финансов', 'совет', 'рекомендац', 'стратег', 'планирован',
            # Дополнительные от меня
            'элит', 'привилеги', 'лаунж', 'консьерж', 'приоритет', 
            'семейн', 'траст', 'оффшор', 'налогов', 'оптимизац', 'филантроп'
        ],
        'phrases': [
            'приват банкинг', 'депозитарная ячейка', 'финансовое планирование',
            'персональный менеджер', 'премиальное обслуживание', 'вип клиент',
            'индивидуальный подход', 'управление капиталом', 'сохранение богатства',
            'приумножение состояния', 'финансовое консультирование', 'банковская ячейка',
            'хранение ценностей', 'сейфовая ячейка', 'конфиденциальное обслуживание',
            'инвестиционная стратегия', 'планирование наследства', 'эксклюзивные продукты',
            'персональные условия', 'управление активами', 'финансовый совет',
            # Дополнительные от меня
            'элитный клуб', 'привилегии вип', 'консьерж сервис', 'приоритетное обслуживание',
            'семейный офис', 'трастовый фонд', 'налоговая оптимизация', 'оффшорные счета'
        ]
    }
}

# Лексикон тональности
SENTIMENT_LEXICON = {
    'positive': {
        'отличн': 2, 'хорош': 2, 'прекрасн': 2, 'быстр': 1, 'удобн': 1, 'понятн': 1,
        'рекоменд': 2, 'довол': 2, 'спасиб': 2, 'рад': 2, 'легк': 1, 'приятн': 1,
        'качествен': 2, 'профессионал': 2, 'оператив': 1, 'четк': 1, 'прозрачн': 1,
        'выгодн': 2, 'надежн': 2, 'лучш': 2, 'супер': 2, 'замечательн': 2, 'впечатл': 2,
        'удовлетворен': 2, 'понравилось': 2, 'нравится': 2, 'вовремя': 1, 'своевремен': 1,
        'гладко': 1, 'эффективн': 1, 'без проблем': 2, 'не плохо': 1, 'без ошибок': 2,
    },
    'negative': {
        'плох': -2, 'ужасн': -3, 'медлен': -2, 'неудобн': -2, 'сложн': -2, 'не нравится': -3,
        'проблем': -2, 'ошибк': -2, 'глюк': -2, 'зависа': -2, 'не работ': -3, 'отказ': -2,
        'обман': -3, 'дорог': -2, 'комисс': -1, 'долг': -2, 'неясн': -1, 'неполадк': -2,
        'недовол': -2, 'разочарован': -3, 'кошмар': -3, 'зависает': -2, 'виснет': -2, 'тупит': -2,
        'лагает': -2, 'маленьк': -1
    }
}

NEGATION_WORDS = {'не', 'нет', 'ни', 'без', 'нельзя', 'невозможно', 'никак', 'ничуть'}

def classify_sentiment(text):
    text = text.lower()
    score = 0
    words = re.findall(r'\w+', text)
    for i, word in enumerate(words):
        for sentiment, lex in SENTIMENT_LEXICON.items():
            for key, val in lex.items():
                if key in word:
                    adjusted_val = val
                    if i > 0 and words[i-1] in NEGATION_WORDS:
                        adjusted_val = -adjusted_val
                    score += adjusted_val
                    break
    if score > 0.5:
        return 'положительно'
    elif score < -0.5:
        return 'отрицательно'
    else:
        return 'нейтрально'

def extract_topic_from_fragment(fragment):
    """Возвращает ТОЛЬКО одну тему: сначала проверяет по категориям"""
    fragment = fragment.lower()
    words = set(re.findall(r'\w+', fragment))
    
    # Проверяем категории (теперь только категории, без subcat, так как в примере topics - это subcat или простые темы)
    for category, data in KEYWORDS.items():
        if any(kw in fragment for kw in data['phrases']) or any(w in words for w in data['keywords']):
            return category
    
    return 'Другое'  # Только в крайнем случае

def random_review_date():
    return '31.05.2025'  # Установлена фиксированная дата, если дата не указана

def process_review(review):
    text = review.get('text', '')
    id = review.get('id', 0)
    
    # Разбиваем на части по союзам-разделителям
    parts = re.split(r'\b(но|зато|однако|а также|при этом|и|но при этом)\b', text, flags=re.IGNORECASE)
    fragments = []
    for i in range(0, len(parts), 2):
        frag = parts[i].strip()
        if i + 1 < len(parts):
            frag += ' ' + parts[i+1].strip()
        if frag:
            fragments.append(frag.strip())
    
    if not fragments:
        fragments = [text]
    
    topics = []
    sentiments = []
    
    for frag in fragments:
        topic = extract_topic_from_fragment(frag)
        if topic == 'Другое' and len(fragments) > 1:
            continue  # Пропускаем 'Другое' если есть другие фрагменты
        sentiment = classify_sentiment(frag)
        topics.append(topic)
        sentiments.append(sentiment)
    
    # Если все 'Другое', оставляем один
    if all(t == 'Другое' for t in topics):
        topics = ['Другое']
        sentiments = [classify_sentiment(text)]
    
    # Удаляем дубликаты тем
    unique = list(dict.fromkeys(zip(topics, sentiments)))
    topics, sentiments = zip(*unique) if unique else (['Другое'], [classify_sentiment(text)])
    
    # Определяем rating
    if len(set(sentiments)) > 1:
        rating = 3
    else:
        first_sent = sentiments[0]
        if first_sent == 'положительно':
            rating = 5
        elif first_sent == 'отрицательно':
            rating = 1
        else:
            rating = 3
    
    return {
        'id': id,
        'text': text,
        'topics': ', '.join(topics),
        'sentiments': ', '.join(sentiments),
        'product_category': ', '.join(topics),
        'date': random_review_date(),
        'rating': rating,
        'author': review.get('author', 'Клиент банка'),
        'source': 'gold'
    }

@st.cache_data
def load_data(uploaded_file):
    if uploaded_file is not None:
        try:
            data = json.load(uploaded_file)
            if 'data' in data and isinstance(data['data'], list):
                predictions = [process_review(review) for review in data['data']]
                df = pd.DataFrame(predictions)
                if not df.empty:
                    df['date'] = pd.to_datetime(df['date'], format='%d.%m.%Y')
                    st.info(f"Загружено {len(df)} отзывов")
                    return df
        except Exception as e:
            st.error(f"Ошибка при загрузке JSON: {e}")
    st.error("Неверный формат JSON. Ожидается {'data': [{'id': 1, 'text': '...'}]}")
    return pd.DataFrame()

# Сайдбар
st.sidebar.header("Загрузка и фильтры")
uploaded_json = st.sidebar.file_uploader("Загрузите JSON с отзывами", type=['json'])

if uploaded_json:
    df = load_data(uploaded_json)
    if not df.empty:
        st.sidebar.header("Фильтры")
        min_date = df['date'].min().date()
        max_date = df['date'].max().date()
        start_date = st.sidebar.date_input("Начальная дата", min_date, min_value=min_date, max_value=max_date)
        end_date = st.sidebar.date_input("Конечная дата", max_date, min_value=min_date, max_value=max_date)

        rating_filter = st.sidebar.slider("Рейтинг", min_value=1, max_value=5, value=(1, 5))

        selected_categories = st.sidebar.multiselect("Категории", options=ALL_CATEGORIES, default=[])

        if selected_categories:
            available_subcategories = [sub for cat in selected_categories for sub in PRODUCT_CATEGORIES.get(cat, [])]
            selected_subcategories = st.sidebar.multiselect("Подкатегории", options=available_subcategories, default=[])
        else:
            selected_subcategories = []

        # Фильтрация
        mask = (df['date'].dt.date >= start_date) & (df['date'].dt.date <= end_date) & (df['rating'].between(*rating_filter))
        
        if selected_categories:
            mask &= df['product_category'].str.contains('|'.join(selected_categories), case=False, na=False)
        if selected_subcategories:
            mask &= df['product_category'].str.contains('|'.join(selected_subcategories), case=False, na=False)

        filtered_df = df[mask].copy()

        # Вывод
        st.subheader("📝 Подробные отзывы")
        st.dataframe(filtered_df[['id', 'text', 'topics', 'sentiments', 'rating', 'date']])

        # Тональность
        st.subheader("😊 Распределение тональности")
        if not filtered_df.empty:
            exploded = filtered_df.copy()
            exploded['sentiments_list'] = exploded['sentiments'].str.split(', ')
            exploded = exploded.explode('sentiments_list')
            sentiment_counts = exploded['sentiments_list'].value_counts()
            fig_sentiment = px.pie(
                names=sentiment_counts.index,
                values=sentiment_counts.values,
                title="Тональность отзывов",
                color=sentiment_counts.index,
                color_discrete_map={'положительно': '#90EE90', 'отрицательно': '#FF6347', 'нейтрально': '#D3D3D3'}
            )
            st.plotly_chart(fig_sentiment, use_container_width=True)

        # Распределение по категориям
        st.subheader("📋 Распределение по категориям продуктов")
        if not filtered_df.empty:
            exploded_cat = filtered_df.copy()
            exploded_cat['cat_list'] = exploded_cat['product_category'].str.split(', ')
            exploded_cat = exploded_cat.explode('cat_list')
            if not selected_categories:
                # Агрегируем по основным категориям, если категории не выбраны
                exploded_cat['cat_list'] = exploded_cat['cat_list'].apply(lambda x: SUBCAT_TO_CAT.get(x.strip(), x) if x != 'Другое' else x)
                exploded_cat = exploded_cat[exploded_cat['cat_list'] != 'Другое']  # Удаляем 'Другое'
                cat_counts = exploded_cat['cat_list'].value_counts()
                fig_cat = px.bar(
                    x=cat_counts.index,
                    y=cat_counts.values,
                    title="Категории и подкатегории",
                    labels={'x': 'Тема', 'y': 'Количество отзывов'},
                    color=cat_counts.index,
                    color_discrete_map={
                        'Повседневные финансы и платежи': '#FF9999',
                        'Сбережения и накопления': '#66B2FF',
                        'Кредитование': '#99FF99',
                        'Инвестиции': '#FFCC99',
                        'Страхование и защита': '#FF99CC',
                        'Премиальные услуги': '#C2C2F0'
                    }
                )
            else:
                cat_counts = exploded_cat['cat_list'].value_counts()
                fig_cat = px.bar(
                    x=cat_counts.index,
                    y=cat_counts.values,
                    title="Категории и подкатегории",
                    labels={'x': 'Тема', 'y': 'Количество отзывов'}
                )
            st.plotly_chart(fig_cat, use_container_width=True)

        # Динамика отзывов по датам (ломаная линия, группировка по темам)
        st.subheader("📅 Динамика отзывов по датам (по темам)")
        if not filtered_df.empty:
            exploded_df = filtered_df.assign(topic=filtered_df['topics'].str.split(', ')).explode('topic')
            if not selected_categories:
                # Агрегируем по основным категориям, если категории не выбраны
                exploded_df['topic'] = exploded_df['topic'].apply(lambda x: SUBCAT_TO_CAT.get(x.strip(), x) if x != 'Другое' else x)
                exploded_df = exploded_df[exploded_df['topic'] != 'Другое']  # Удаляем 'Другое'
            exploded_df['date_str'] = exploded_df['date'].dt.date.astype(str)
            count_by_date_topic = exploded_df.groupby(['date_str', 'topic']).size().reset_index(name='count')
            fig_date = px.line(
                count_by_date_topic,
                x='date_str',
                y='count',
                color='topic',
                title="Динамика количества отзывов по датам и темам",
                labels={'date_str': 'Дата', 'count': 'Количество отзывов', 'topic': 'Тема'},
                color_discrete_map={
                    'Повседневные финансы и платежи': '#FF9999',
                    'Сбережения и накопления': '#66B2FF',
                    'Кредитование': '#99FF99',
                    'Инвестиции': '#FFCC99',
                    'Страхование и защита': '#FF99CC',
                    'Премиальные услуги': '#C2C2F0'
                } if not selected_categories else None
            )
            st.plotly_chart(fig_date, use_container_width=True)
    else:
        st.write("Нет данных для анализа.")
else:
    st.sidebar.warning("Загрузите JSON с отзывами для анализа")
    st.write("Загрузите JSON с отзывами в сайдбаре.")
